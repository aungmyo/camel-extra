= Guice JNDI =

The Guice JNDI provider makes it easy to create a JNDI context using Guice as the dependency injection mechanism letting you use the power of Guice Dependency Injection while still supporting JNDI which allows clients to look up objects in JNDI while using Guice to create them.

== Creating the Guice JNDI provider ==

To create a Guice JNDI provider you need to create a *jndi.properties* file on the classpath. Then you can use JNDI as follows

{{{
    InitialContext context = new InitialContext();
}}}

Or if you prefer you can configure a Hashtable with the entries inside (which we'll discuss shortly)...

{{{
    Hashtable properties = new Hashtable();
    // setup the properties...
    InitialContext context = new InitialContext(properties);
}}}

=== Specifiying the properties ===

You must specify the following properties as a bare minimum

{{{
# Guice JNDI provider
java.naming.factory.initial = com.google.inject.jndi.GuiceInitialContextFactory

# list of guice modules to boot up (space separated)
guice.modules = com.acme.MyModule
}}}

The *guice.modules* defines a space separated list of Guice modules to add to the Guice Injector.

== Binding to @Named injection points ==

The entries in the jndi.properties file will be used to bind any @Named injection points in your guice beans.

For example if you used this properties file

{{{
# Guice JNDI provider
java.naming.factory.initial = com.google.inject.jndi.GuiceInitialContextFactory

# default modules to boot up
guice.modules = com.acme.MyModule

# guice injection properties
cheese.type = Edam
}}}

Then this would bind to an instance of 

{{{
public class Cheese {
  @Inject
  public Cheese(@Named("cheese.type") String type) {...
  }
}
}}}

== Exposing intances from the Injector into JNDI ==

Any binding in Guice which has no other annotations attached is visible using its bound type name. For example to lookup the Guice Injector in JNDI you can use

{{{
  Injector injector = (Injector) context.lookup("com.google.inject.Injector");
}}}

By default any @Named instance will be exposed in JNDI using the naming convention

{{{
className/name
}}}

In addition you can attach the @JndiBind annotation to any class or provider method to expose objects directly into JNDI.

For example

{{{
@JndiBind("cheese")
public class Cheese {

  @Inject
  public Cheese(@Named("cheese.type") String type) {...
  }
}
}}}

The Cheese object will be bound to the JNDI name "cheese" and be injected with the "cheese.type" entry in the jndi.properties file.

Another option is to use the annotation in a module's provider method

{{{
public class ExampleModule extends AbstractModule {
  ...

  @Provides
  @JndiBind("blah")
  public MyBean makeBlah() {
    return new MyBean(new AnotherBean("Blah.another"), "Blah");
  }
}
}}}

Which will bind the result of makeBlah() to the JNDI name  "blah" 